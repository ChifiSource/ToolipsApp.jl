<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>core · toolips</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="toolips logo"/></a><div class="docs-package-name"><span class="docs-autofit">toolips</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">reference</span><ul><li><a class="tocitem" href="../">toolips</a></li><li><a class="tocitem" href="../overview/">overview</a></li><li class="is-active"><a class="tocitem" href>core</a><ul class="internal"><li><a class="tocitem" href="#connections"><span>connections</span></a></li><li><a class="tocitem" href="#routes"><span>routes</span></a></li><li><a class="tocitem" href="#servers"><span>servers</span></a></li><li><a class="tocitem" href="#requests"><span>requests</span></a></li></ul></li><li><a class="tocitem" href="../interface/">interface</a></li></ul></li><li><span class="tocitem">server extensions</span><ul><li><a class="tocitem" href="../extensions/toolips_session/">toolips session</a></li><li><a class="tocitem" href="../extensions/toolips_defaults/">toolips defaults</a></li><li><a class="tocitem" href="../extensions/toolips_markdown/">toolips markdown</a></li><li><a class="tocitem" href="../extensions/toolips_base64/">toolips base64</a></li><li><a class="tocitem" href="../extensions/toolips_memwrite/">toolips memwrite</a></li><li><a class="tocitem" href="../extensions/toolips_remote/">toolips remote</a></li><li><a class="tocitem" href="../extensions/toolips_uploader/">toolips uploader</a></li><li><a class="tocitem" href="../extensions/toolips_interpolator/">toolips interpolator</a></li><li><a class="tocitem" href="../extensions/toolips_export/">toolips export</a></li><li><a class="tocitem" href="../extensions/creating_extensions/">creating extensions</a></li></ul></li><li><span class="tocitem">examples</span><ul><li><a class="tocitem" href="../examples/simple_api/">simple api</a></li><li><a class="tocitem" href="../examples/simple_website/">simple website</a></li><li><a class="tocitem" href="../examples/blog/">blog</a></li><li><a class="tocitem" href="../examples/text_editor/">text editor</a></li></ul></li><li><a class="tocitem" href="../developer_api/">developer API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">reference</a></li><li class="is-active"><a href>core</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>core</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChifiSource/Toolips.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins&family=Roboto+Mono:wght@100&family=Rubik:wght@500&display=swap" rel="stylesheet">

<style>
body {background-color: #FDF8FF !important;}
header {background-color: #FDF8FF !important}
h1 {
  font-family: 'Poppins', sans-serif !important;
  font-family: 'Roboto Mono', monospace !important;
  font-family: 'Rubik', sans-serif !important;}

  h2 {
    font-family: 'Poppins', sans-serif !important;
    font-family: 'Roboto Mono', monospace !important;
    font-family: 'Rubik', sans-serif !important;}
    h4 { color: #03045e !important;
      font-family: 'Poppins', sans-serif !important;
      font-family: 'Roboto Mono', monospace !important;
      font-family: 'Rubik', sans-serif !important;}
      article {
        border-radius: 30px !important;
        border-color: lightblue !important;
      }
      pre {
        border-radius: 10px !important;
        border-color: #FFE5B4 !important;
      }
p {font-family: 'Poppins', sans-serif;
font-family: 'Roboto Mono', monospace;
font-family: 'Rubik', sans-serif; color: #565656;}
button {border-radius: 5px; padding: 7px; background-color: lightblue;
color: white; font-size: 16pt; font-weight: bold; border-style: none; cursor: pointer; margin: 5px;}
button:hover {background-color: orange;}
</style><h1 id="core"><a class="docs-heading-anchor" href="#core">core</a><a id="core-1"></a><a class="docs-heading-anchor-permalink" href="#core" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Toolips.AbstractRoute" href="#Toolips.AbstractRoute"><code>Toolips.AbstractRoute</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type AbstractRoute</strong></p><p>Abstract Routes are what connect incoming connections to functions. Each route must have two fields, <code>path</code>, and <code>page</code>. Path needs to be a String, but that is about it.</p><p><strong>Consistencies</strong></p><ul><li>type::T where T == Vector{Symbol}  || T == Symbol</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.Servable" href="#Toolips.Servable"><code>Toolips.Servable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type Servable</strong></p><p>Servables can be written to a Connection via their f() function and the interface. They can also be indexed with strings or symbols to change properties</p><p><strong>Consistencies</strong></p><ul><li>f::Function - Function whose output to be written to http. Must take a single</li></ul><p>positonal argument of type ::Connection or ::AbstractConnection</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.AbstractConnection" href="#Toolips.AbstractConnection"><code>Toolips.AbstractConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type AbstractConnection</strong></p><p>Connections are passed through function routes and can have Servables written     to it.</p><p><strong>Consistencies</strong></p><ul><li>routes::Dict - A {String, Function} dictionary that the server references to</li></ul><p>direct incoming connections.</p><ul><li>http::Any - Usually an HTTP.Stream, however can be anything that is binded to</li></ul><p>the Base.write method, or the Toolips.write! method.</p><ul><li>extensions::Dict - A {Symbol, ServerExtension} dictionary that can be used to</li></ul><p>access ServerExtensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerExtension" href="#Toolips.ServerExtension"><code>Toolips.ServerExtension</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ServerExtension</strong></p><p>Server extensions are loaded into the server on startup, and can have a few different abilities according to their type field&#39;s value. This value can be either a Symbol or a Vector of Symbols.</p><p><strong>Consistencies</strong></p><ul><li>type::T where T == Vector{Symbol}  || T == Symbol. The type can be :routing,</li></ul><p>:func, :connection, or any combination inside of a Vector{Symbol}.</p><ul><li>:routing extensions are called once at server creation, and must have</li></ul><p>the field <code>f(r::Vector{AbstractRoute}, e::Vector{ServerExtension})</code>.</p><ul><li>:func extensions are called each time the server is routed, and must have</li></ul><p>the field <code>f(c::AbstractConnection)</code>.</p><ul><li>:connection extensions are passed inside of the Connection.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.ToolipsServer" href="#Toolips.ToolipsServer"><code>Toolips.ToolipsServer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ToolipsServer</strong></p><p>ToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.</p><p><strong>Consistencies</strong></p><ul><li>routes::Vector{AbstractRoute} - The server&#39;s routes.</li><li>extensions::Vector{Route} - The server&#39;s currently loaded extensions.</li><li>server::Any - The server, whatever type it may be...</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.CoreException" href="#Toolips.CoreException"><code>Toolips.CoreException</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type CoreException</strong></p><p>Core Exceptions are thrown whenever a random Core error happens.</p><p><strong>Consistencies</strong></p><ul><li>type::T where T == Vector{Symbol}  || T == Symbol</li></ul></div></section></article><h2 id="connections"><a class="docs-heading-anchor" href="#connections">connections</a><a id="connections-1"></a><a class="docs-heading-anchor-permalink" href="#connections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.SpoofStream" href="#Toolips.SpoofStream"><code>Toolips.SpoofStream</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SpoofStream</strong></p><ul><li>text::String</li></ul><p>The SpoofStream allows us to fake a connection by building a SpoofConnection which will write to the SpoofStream.text field whenever write! is called. This is useful for testing, or just writing servables into a string.</p><p><strong>example</strong></p><pre><code class="language-none">stream = SpoofStream()
write(stream, &quot;hello!&quot;)
println(stream.text)

    hello!
conn = SpoofConnection()
servab = Component()
write!(conn, servab)</code></pre><hr/><p><strong>field info</strong></p><ul><li>text::String - The text written to the stream.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>SpoofStream()</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.Connection" href="#Toolips.Connection"><code>Toolips.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Connection &lt;: AbstractConnection</strong></p><ul><li>routes::Dict</li><li>http::HTTP.Stream</li><li>extensions::Dict</li></ul><p>The connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.</p><p><strong>example</strong></p><pre><code class="language-none">                  #  v The Connection
home = route(&quot;/&quot;) do c::Connection
    c[Logger].log(1, &quot;We can index extensions by type or symbol&quot;)
    c[:logger].log(1, &quot;see?&quot;)
    c.routes[&quot;/&quot;] = c::Connection -&gt; write!(c, &quot;rerouting!&quot;)
    httpstream = c.http
    write!(c, &quot;Hello world!&quot;)
    myheading::Component = h(&quot;myheading&quot;, 1, text = &quot;Whoa!&quot;)
    write!(c, myheading)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li><strong>routes::Dict</strong> - A dictionary of routes where the keys</li></ul><p>are the routed URL and the values are the functions to those keys.</p><ul><li><strong>http::HTTP.Stream</strong> - The stream for this current peer&#39;s connection.</li><li><strong>extensions::Dict</strong> - A dictionary of extensions to load with the</li></ul><p><strong>name to reference as keys and the extension as the pair.</strong></p><p><strong>constructors</strong></p><ul><li>Connection(routes::Dict, http::HTTP.Stream, extensions::Dict)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.SpoofConnection" href="#Toolips.SpoofConnection"><code>Toolips.SpoofConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SpoofConnection &lt;: AbstractConnection</strong></p><ul><li>routes::Dict</li><li>http::SpoofStream</li><li>extensions::Dict -</li></ul><p>Builds a fake connection with a SpoofStream. Useful if you want to write a Servable without a server.</p><p><strong>example</strong></p><pre><code class="language-none">fakec = SpoofConnection()
servable = Component()
# write!(::AbstractConnection, ::Servable):
write!(fakec, servable)</code></pre><hr/><p><strong>field info</strong></p><ul><li>routes::Dict - A dictionary of routes, usually left empty.</li><li>http::SpoofStream - A fake http stream that instead writes output to a string.</li><li>extensions::Dict - A dictionary of extensions, usually empty.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>SpoofStream(r::Dict, http::SpoofStream, extensions::Dict)</li><li>SpoofStream()</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Symbol}" href="#Base.getindex-Tuple{AbstractConnection, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Core</strong></p><p><strong>getindex(c::AbstractConnection, s::Symbol) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    c[:Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Type}" href="#Base.getindex-Tuple{AbstractConnection, Type}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Core</strong></p><p><strong>getindex(c::AbstractConnection, t::Type) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c by type.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    c[Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractConnection, Function, String}" href="#Base.setindex!-Tuple{AbstractConnection, Function, String}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Core</strong></p><p><strong>setindex!(c::AbstractConnection, f::Function, s::String) -&gt; _</strong></p><hr/><p>Sets the route path s to serve at the function f.</p><p><strong>example</strong></p><pre><code class="language-none">c[&quot;/&quot;] = c -&gt; write!(c, &quot;hello&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractConnection, AbstractRoute, String}" href="#Base.setindex!-Tuple{AbstractConnection, AbstractRoute, String}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Core</strong></p><p><strong>setindex!(c::AbstractConnection, f::Function, s::String) -&gt; _</strong></p><hr/><p>Sets the route path s to serve at the function f.</p><p><strong>example</strong></p><pre><code class="language-none">c[&quot;/&quot;] = c -&gt; write!(c, &quot;hello&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!" href="#Toolips.write!"><code>Toolips.write!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Servable) -&gt; _</strong></p><hr/><p>Writes a Servable&#39;s return to a Connection&#39;s stream. This is usually used in a routing function or a route where ::Connection is provided as an argument.</p><p><strong>example</strong></p><pre><code class="language-none">serv = p(&quot;mycomp&quot;, text = &quot;hello&quot;)

rt = route(&quot;/&quot;) do c::Connection
    write!(c, serv)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{Servable}) -&gt; _</strong></p><hr/><p>Writes all servables in s to c.</p><p><strong>example</strong></p><pre><code class="language-none">c = AbstractComponent()
c2 = AbstractComponent()
comps = components(c, c2)
    Vector{Servable}(AbstractComponent(), AbstractComponent())

write!(c, comps)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Servable ...) -&gt; _</strong></p><hr/><p>Writes Servables as Vector{Servable}</p><p><strong>example</strong></p><pre><code class="language-none">write!(c, p(&quot;mycomp&quot;, text = &quot;hello!&quot;), p(&quot;othercomp&quot;, text = &quot;hi!&quot;))</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{AbstractComponent}) -&gt; _</strong></p><hr/><p>A catch-all for when Vectors are accidentally stored as Vector{Any}.</p><p><strong>example</strong></p><pre><code class="language-none">write!(c, [&quot;hello&quot;, p(&quot;mycomp&quot;, text = &quot;hello!&quot;)])</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(::AbstractConnection, ::Any) -&gt; _</strong></p><hr/><p>Attempts to write any type to the Connection&#39;s stream.</p><p><strong>example</strong></p><pre><code class="language-none">d = 50
write!(c, d)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getargs" href="#Toolips.getargs"><code>Toolips.getargs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>getargs(c::AbstractConnection) -&gt; ::Dict{Symbol, Any}</strong></p><hr/><p>The getargs method returns arguments from the HTTP target (GET requests.) Returns a Dict with the argument keys as Symbols.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c
    args = getargs(c)
    args[:message]
        &quot;welcome to toolips ! :)&quot;
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getarg" href="#Toolips.getarg"><code>Toolips.getarg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol) -&gt; ::Any</strong></p><hr/><p>Returns the requested argument from the target.</p><p><strong>example</strong></p><pre><code class="language-none">getarg(c, :x)
    50</code></pre></div></section><section><div><p><strong>Core</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol, t::Type) -&gt; ::Vector</strong></p><hr/><p>This method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that &quot;Cannot convert...&quot; errors are possible with this method.</p><p><strong>example</strong></p><pre><code class="language-none">getarg(c, :x, Int64)
    50</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getip" href="#Toolips.getip"><code>Toolips.getip</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>getip(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the IP that is connected via the connection c.</p><p><strong>example</strong></p><pre><code class="language-none">getip(c)
&quot;127.0.0.2&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getpost" href="#Toolips.getpost"><code>Toolips.getpost</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>getpost(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the POST body of c.</p><p><strong>example</strong></p><pre><code class="language-none">getpost(c)
&quot;hello, this is a post request&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.download!" href="#Toolips.download!"><code>Toolips.download!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>download!(c::AbstractConnection, uri::String) -&gt; _</strong></p><hr/><p>Downloads a file to a given Connection&#39;s computer.</p><p><strong>example</strong></p><pre><code class="language-none">download!(c, &quot;files/mytext.txt&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.navigate!" href="#Toolips.navigate!"><code>Toolips.navigate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>navigate!(::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Routes a connected stream to a given URL.</p><p><strong>example</strong></p><pre><code class="language-none">navigate!(c, &quot;https://github.com/ChifiSource/Toolips.jl&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Tuple{AbstractConnection, Any}" href="#Base.push!-Tuple{AbstractConnection, Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>push!(c::AbstractConnection, data::Any) -&gt; _</strong></p><hr/><p>A &quot;catch-all&quot; for pushing data to a stream. Produces a full response with <strong>data</strong> as the body.</p><p><strong>example</strong></p><pre><code class="language-none"></code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.startread!-Tuple{AbstractConnection}" href="#Toolips.startread!-Tuple{AbstractConnection}"><code>Toolips.startread!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>startread!(::AbstractConnection) -&gt; _</strong></p><hr/><p>Resets the seek on the Connection. This function is only meant to be used on post bodies.</p><p><strong>example</strong></p><pre><code class="language-none">post = getpost(c)
    &quot;hello&quot;
post = getpost(c)
    &quot;&quot;
startread!(c)
post = getpost(c)
    &quot;hello&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!-Tuple{AbstractConnection, AbstractRoute}" href="#Toolips.route!-Tuple{AbstractConnection, AbstractRoute}"><code>Toolips.route!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(c::AbstractConnection, route::Route) -&gt; _</strong></p><hr/><p>Modifies the route on the Connection.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    r = route(&quot;/&quot;) do c::Connection
        write!(c, &quot;hello&quot;)
    end
    route!(c, r)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!-Tuple{Function, AbstractConnection, String}" href="#Toolips.route!-Tuple{Function, AbstractConnection, String}"><code>Toolips.route!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(::Function, ::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Routes a given String to the Function.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c
    route!(c, &quot;/&quot;) do c
        println(&quot;tacos&quot;)
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.unroute!-Tuple{AbstractConnection, String}" href="#Toolips.unroute!-Tuple{AbstractConnection, String}"><code>Toolips.unroute!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>unroute!(::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Removes the route with the key equivalent to the String.</p><p><strong>example</strong></p><pre><code class="language-none"># One request will kill this route:
route(&quot;/&quot;) do c::Connection
    unroute!(c, &quot;/&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes-Tuple{AbstractConnection}" href="#Toolips.routes-Tuple{AbstractConnection}"><code>Toolips.routes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(c::Connection) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    routes(c)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.extensions-Tuple{AbstractConnection}" href="#Toolips.extensions-Tuple{AbstractConnection}"><code>Toolips.extensions</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>extensions(c::Connection) -&gt; ::Dict{Symbol, ServerExtension}</strong></p><hr/><p>Returns the server&#39;s extensions.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    extensions(c)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.has_extension" href="#Toolips.has_extension"><code>Toolips.has_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>has_extension(c::AbstractConnection, t::Type) -&gt; ::Bool</strong></p><hr/><p>Checks if c.extensions has an extension of type t.</p><p><strong>example</strong></p><pre><code class="language-none">if has_extension(c, Logger)
    c[:Logger].log(&quot;it has a logger, I think.&quot;)
end</code></pre></div></section><section><div><p><strong>Internals</strong></p><p><strong>has_extension(d::Dict, t::Type) -&gt; ::Bool</strong></p><hr/><p>Checks if d has an extension of type t.</p><p><strong>example</strong></p><pre><code class="language-none">if has_extension(d, Logger)
    d[:Logger].log(&quot;it has a logger, I think.&quot;)
end</code></pre></div></section></article><h2 id="routes"><a class="docs-heading-anchor" href="#routes">routes</a><a id="routes-1"></a><a class="docs-heading-anchor-permalink" href="#routes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.Route" href="#Toolips.Route"><code>Toolips.Route</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Route</strong></p><ul><li>path<strong>::String</strong>  - The path to route to the function, e.g. &quot;/&quot;.</li><li>page<strong>::Function</strong> - The function to route the path to.</li></ul><p>A route is added to a ToolipsServer using either its constructor, or the ToolipsServer.add(<strong>::Route</strong>) method. Each route calls a function. The Route type is commonly constructed using the do syntax with the route(<strong>::Function</strong>, <strong>::String</strong>) method.</p><p><strong>example</strong></p><pre><code class="language-none"># Constructors
route = Route(&quot;/&quot;, p(text = &quot;hello&quot;))

function example(c::Connection)
    write!(c, &quot;hello&quot;)
end

route = Route(&quot;/&quot;, example)

# method
route = route(&quot;/&quot;) do c
    write!(c, &quot;Hello world!&quot;)
    write!(c, p(text = &quot;hello&quot;))
    # we can also use extensions!
    c[:logger].log(&quot;hello world!&quot;)
end</code></pre><hr/><p><strong>constructors</strong></p><ul><li>Route(path<strong>::String</strong>, f<strong>::Function</strong>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route" href="#Toolips.route"><code>Toolips.route</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>route(f::Function, r::String) -&gt; ::Route</strong></p><hr/><p>Creates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection

end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route(r::String, f::Function) -&gt; ::Route</strong></p><hr/><p>Creates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.</p><p><strong>example</strong></p><pre><code class="language-none">function example(c::Connection)
    write!(c, h(&quot;myh&quot;, 1, text = &quot;hello!&quot;))
end
r = route(&quot;/&quot;, example)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes" href="#Toolips.routes"><code>Toolips.routes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(c::Connection) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="language-none">route(&quot;/&quot;) do c::Connection
    routes(c)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>routes(::Route ...) -&gt; ::Vector{Route}</strong></p><hr/><p>Turns routes provided as arguments into a Vector{Route} with indexable routes. This is useful because this is the type that the ServerTemplate constructor likes. This function is also used as a &quot;getter&quot; for ToolipsServers and Connections, see ?(routes(::ToolipsServer)) &amp; ?(routes(::AbstractConnection))</p><p><strong>example</strong></p><pre><code class="language-none">r1 = route(&quot;/&quot;) do c::Connection
    write!(c, &quot;pickles&quot;)
end
r2 = route(&quot;/pickles&quot;) do c::Connection
    write!(c, &quot;also pickles&quot;)
end
rts = routes(r1, r2)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>routes(ws::ToolipsServer) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
routes(ws)
    &quot;/&quot; =&gt; home
    &quot;404&quot; =&gt; fourohfour</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{Vector{AbstractRoute}, Function, String}" href="#Base.setindex!-Tuple{Vector{AbstractRoute}, Function, String}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>setindex!(rs::Vector{AbstractRoute}, f::Function, s::String)</strong></p><hr/><p>Sets a given route in a Vector to a function.</p><p><strong>example</strong></p><pre><code class="language-none">function example(c::Connection)
    write!(c, h(&quot;myh&quot;, 1, text = &quot;hello!&quot;))
end
r = route(&quot;/&quot;, example)
rts = [r]
rts[&quot;/&quot;] = (c::Connection) -&gt; write!(c, p(text = &quot;no longer a heading&quot;))</code></pre></div></section></article><h2 id="servers"><a class="docs-heading-anchor" href="#servers">servers</a><a id="servers-1"></a><a class="docs-heading-anchor-permalink" href="#servers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.WebServer" href="#Toolips.WebServer"><code>Toolips.WebServer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>WebServer &lt;: ToolipsServer</strong></p><ul><li>host<strong>::String</strong></li><li>routes<strong>::Dict</strong></li><li>extensions<strong>::Dict</strong></li><li>server<strong>::Any</strong></li><li>add<strong>::Function</strong></li><li>remove<strong>::Function</strong></li><li>start<strong>::Function</strong></li></ul><p>A web-server is given as a return from a ServerTemplate whenever ServerTemplate.start() is ran. It can be rerouted with route! and indexed similarly to the Connection, with Symbols representing extensions and Strings representing routes.</p><p><strong>example</strong></p><pre><code class="language-none">st = ServerTemplate()
ws = st.start()
routes(ws)
...
extensions(ws)
...
route!(ws, &quot;/&quot;) do c::Connection
    write!(c, &quot;hello&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerTemplate" href="#Toolips.ServerTemplate"><code>Toolips.ServerTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>ServerTemplate</strong></p><ul><li>host<strong>::String</strong></li><li>port<strong>::Integer</strong></li><li>routes<strong>::Vector{AbstractRoute}</strong></li><li>extensions<strong>::Vector{ServerExtension}</strong></li><li>remove<strong>::Function</strong></li><li>add<strong>::Function</strong></li><li>start<strong>::Function</strong></li></ul><p>The ServerTemplate is used to configure a server before running. These are commonly used for reproducibility, especially when it comes to making servers from extensions</p><p><strong>example</strong></p><pre><code class="language-none">home(c::Connection) = begin
    write!(c, p(text = &quot;hello world!&quot;))
end

st = ServerTemplate(&quot;127.0.0.1&quot;, 8000, routes = [Route(&quot;/&quot;, home)])

webserver = ServerTemplate.start()</code></pre><hr/><p><strong>field info</strong></p><ul><li>ip<strong>::String</strong> - IP the server should serve to.</li><li>port<strong>::Integer</strong> - Port to listen on.</li><li>routes<strong>::Vector{AbstractRoute}</strong> - A vector of routes to provide to the server</li><li>extensions<strong>::Vector{ServerExtension}</strong> - A vector of extensions to load into</li></ul><p>the server.</p><ul><li>remove(::Int64)<strong>::Function</strong> - Removes routes by index.</li><li>remove(::String)<strong>::Function</strong> - Removes routes by name.</li><li>remove(::Symbol)<strong>::Function</strong> - Removes extension by Symbol representing</li></ul><p>type, e.g. :Logger</p><ul><li>add(::Route ...)<strong>::Function</strong> - Adds the routes to the server.</li><li>add(::ServerExtension ...)<strong>::Function</strong> - Adds the extensions to the server.</li><li>start()<strong>::Function</strong> - Starts the server.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>ServerTemplate(ip::String = &quot;127.0.0.1&quot;, port::Int64 = 8001,           routes::Vector{AbstractRoute} = Vector{AbstractRoute}());           extensions::Vector{ServerExtension} = [Logger()]           connection::Type)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ToolipsServer, Symbol}" href="#Base.getindex-Tuple{ToolipsServer, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(ws::ToolipsServer, s::Symbol) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in ws.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
ws[:Logger].log(&quot;hi&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes-Tuple{ToolipsServer}" href="#Toolips.routes-Tuple{ToolipsServer}"><code>Toolips.routes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(ws::ToolipsServer) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
routes(ws)
    &quot;/&quot; =&gt; home
    &quot;404&quot; =&gt; fourohfour</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.extensions-Tuple{ToolipsServer}" href="#Toolips.extensions-Tuple{ToolipsServer}"><code>Toolips.extensions</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>extensions(ws::ToolipsServer) -&gt; ::Dict{Symbol, ServerExtension}</strong></p><hr/><p>Returns the server&#39;s extensions.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
extensions(ws)
    Logger(blah blah blah)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.kill!-Tuple{ToolipsServer}" href="#Toolips.kill!-Tuple{ToolipsServer}"><code>Toolips.kill!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>kill!(ws::ToolipsServer) -&gt; _</strong></p><hr/><p>Closes the web-server.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
kill!(ws)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.kill!-Tuple{ServerTemplate}" href="#Toolips.kill!-Tuple{ServerTemplate}"><code>Toolips.kill!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>kill!(ws::ToolipsServer) -&gt; _</strong></p><hr/><p>Closes the web-server.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
kill!(ws)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!-Tuple{Function, ToolipsServer, String}" href="#Toolips.route!-Tuple{Function, ToolipsServer, String}"><code>Toolips.route!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(f::Function, ws::ToolipsServer, r::String) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r to function f.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
route!(ws, &quot;/&quot;) do c
    c[:Logger].log(&quot;rerouted!&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!-Tuple{ToolipsServer, String, Function}" href="#Toolips.route!-Tuple{ToolipsServer, String, Function}"><code>Toolips.route!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(ws::ToolipsServer, r::String, f::Function) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r to function f.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()

function myf(c::Connection)
    write!(c, &quot;pasta&quot;)
end
route!(ws, &quot;/&quot;, myf)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!-Tuple{ToolipsServer, AbstractRoute}" href="#Toolips.route!-Tuple{ToolipsServer, AbstractRoute}"><code>Toolips.route!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(ws::ToolipsServer, r::Route) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r.</p><p><strong>example</strong></p><pre><code class="language-none">ws = MyProject.start()
r = route(&quot;/&quot;) do c

end
route!(ws, r)</code></pre></div></section></article><h2 id="requests"><a class="docs-heading-anchor" href="#requests">requests</a><a id="requests-1"></a><a class="docs-heading-anchor-permalink" href="#requests" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{String}" href="#Base.get-Tuple{String}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Core</strong></p><p><strong>get(url::String) -&gt; ::String</strong></p><hr/><p>Quick binding for an HTTP GET request.</p><p><strong>example</strong></p><pre><code class="language-none">body = get(&quot;/&quot;)
    &quot;hi&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.post" href="#Toolips.post"><code>Toolips.post</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>post(url::String, body::String) -&gt; ::String</strong></p><hr/><p>Quick binding for an HTTP POST request.</p><p><strong>example</strong></p><pre><code class="language-none">response = post(&quot;/&quot;)
    &quot;my response&quot;</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« overview</a><a class="docs-footer-nextpage" href="../interface/">interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 August 2022 17:29">Thursday 4 August 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
